---
title: Jenkins X について
linktitle: Jenkins X について
description: Jenkins X のコンセプトの概要
type: docs
menu:
  main:
    weight: 10
cascade:
  type: docs
aliases:
    - /getting-started/boot/
    - /docs/reference/boot
---

## コンセプト
---
Jenkins X は、開発者が DevOps の原則とベストプラクティスに取り組むことができるように設計されています。
このアプローチは、書籍 [*ACCELERATE: Building and Scaling High Performing Technology Organisations*](https://goo.gl/vZ8BFN) のために行われた包括的な研究に基づいています。Jenkins X の背後にある原理については、Accelerate を使用する理由を読み取ることができます。


## 原理
---
*"DevOps とは、システムに変更をコミットしてから通常の運用に移るまでの時間を短縮し、高品質を確保することを目的とした一連のプラクティスです。"*

DevOps プロジェクトの目的は

* 市場投入までの時間を短縮
* デプロイ頻度の向上
* 修正間隔の短縮
* リリースの失敗率を下げる
* 回復までの平均時間の短縮

高いパフォーマンスを発揮するチームは、週に1回から月に1回の業界平均と比較して、1日に複数回のデプロイを行うことができなければなりません。

コードが「コミットされたコード」から「本番のコード」に移行するまでのリードタイムは1時間未満で、変更失敗率は平均31～45%であるのに対し、15%未満でなければなりません。

また、障害復旧までの平均時間も1時間未満であることが望ましいです。

Jenkins X は，業界トップのパフォーマンス目標を達成するために，チームが DevOps のベストプラクティスを適用できるように，第一原理に基づいて設計されています。

## プラクティス
---
DevOps アプローチを成功させるためには、以下のベストプラクティスが鍵になると考えられています。

* 疎結合アーキテクチャ
* セルフサービスの設定
* 自動化されたプロビジョニング
* 継続的なビルド/インテグレーションとデリバリ
* 自動化されたリリース管理
* インクリメンタルテスト
* コードとしてのインフラ構成
* 包括的な構成管理
* トランクベースの開発と機能フラグ

Jenkins X では，多くの使い慣れた方法論やコンポーネントを統合して，複雑さを最小限に抑えた統合的なアプローチを採用している。

## アーキテクチャ

Jenkins X は、疎結合アーキテクチャの DevOps モデルに基づいて構築されており、複数のチームにまたがって反復可能で管理可能な方法で大量の分散マイクロサービスをデプロイすることをサポートするように設計されています。

<img src="/images/jx-arch.png" class="img-thumbnail">

### 概念モデル

<img src="/images/model.png" class="img-thumbnail">

## 構成要素

Jenkins X は以下のコアコンポーネントをベースに構築されています。

### Kubernetes & Docker
---
システムの中心にあるのは、DevOps のためのデファクトな仮想インフラプラットフォームとなっている Kubernetes です。現在、すべての主要なクラウドプロバイダが Kubernetes インフラストラクチャをオンデマンドで提供しており、必要に応じてプライベートインフラストラクチャに自社でプラットフォームをインストールすることも可能です。

機能的には、Kubernetes プラットフォームは、Docker が提供する基本的なコンテナ化の原則を拡張し、複数の物理ノードにまたがっています。

簡単に言えば、Kubernetes はノードを追加したり削除したりすることで動的にスケーリングできる均質な仮想インフラストラクチャを提供します。各ノードは、単一の大きなフラットなプライベート仮想ネットワーク空間に参加しています。

Kubernetes でのデプロイの単位は Pod であり、1つ以上の Docker コンテナといくつかのメタデータで構成されています。Pod 内のすべてのコンテナは、同じ仮想 IP アドレスとポート空間を共有します。Kubernetes 内でのデプロイは宣言的なもので、ユーザーはデプロイする Pod の指定されたバージョンのインスタンス数を指定し、Kubernetes はノード間で Pod をデプロイまたは削除することで、現在の状態から目的の状態に到達するために必要なアクションを計算します。Pod の特定のインスタンスがどこにインスタンス化されるかの決定は、利用可能なリソース、希望するリソース、ラベルマッチングに影響されます。一度デプロイされると、Kubernetes は、定期的なヘルスチェックを実行し、反応しない Pod を終了させて交換することで、各タイプの必要な数の Pod が稼働し続けることを保証することを約束します。

ある程度の構造を課すために、Kubernetes では仮想の名前空間を作成し、これを使用して Pod を論理的に分離したり、Pod のグループを特定のリソースに関連付けることができます。名前空間内のリソースは、例えば、単一のセキュリティポリシーを共有することができます。リソース名は名前空間内で一意である必要がありますが、名前空間同士で再利用することができます。

Jenkins X モデルでは、Pod は (ほとんどの場合) マイクロサービスのデプロイされたインスタンスに相当します。マイクロサービスを水平方向にスケーリングする必要がある場合、Kubernetes では、特定の Pod の同一のインスタンスを複数デプロイし、それぞれが独自の仮想 IP アドレスを持つことができます。これらのインスタンスは、サービスとして知られる単一の仮想エンドポイントに集約することができ、サービス名と一致する一意の静的 IP アドレスとローカル DNS エントリを持っています。Service への呼び出しは、ランダムに健全な Pod インスタンスの1つの IP に動的にリマップされます。サービスはポートのリマップにも使用できます。Kubernetes 仮想ネットワーク内では、サービスは完全修飾ドメイン名を使用して参照することができます。これを短縮して `<サービス名>.<名前空間名>.svc.cluster.local` と呼ぶこともできますし、同じ名前空間に属するサービスの場合は `<サービス名>.<名前空間名>` と呼ぶこともできます。したがって、'finance' という名前の名前空間にデプロイされた 'payment' という名前の RESTful サービスは、呼び出したコードの場所に応じて、`http://payments.finance.svc.cluster.local`、`http://payments.finance`、または単に `http://payments` を介してコード内で参照することができます。

ローカルネットワークの外部からサービスにアクセスするためには、Kubernetes はサービスごとに Ingress を作成する必要があります。最も一般的な方法は、静的なIPアドレスを持つ1つ以上のロードバランサーを利用することです。ロードバランサーの静的 IP アドレスにワイルドカードの外部 DNS エントリを作成することで、サービスを外部の完全修飾ドメイン名にマッピングすることが可能になります。例えば、ロードバランサーが `*.jenkins-x.io` にマップされている場合、支払いサービスは `http://payments.finance.jenkins-x.io` として公開されます。

Kubernetes は、大規模なサービスをデプロイするための強力なプラットフォームであり、常に改善されていますが、理解するのが複雑で、正しく設定するのが難しい場合もあります。Jenkins X は Kubernetes に一連のデフォルトの規約といくつかの簡素化されたツールをもたらし、DevOps や疎結合サービスの管理の目的に最適化されています。

コマンドラインツール `jx` は、ログの閲覧やコンテナインスタンスへの接続など、Kubernetes インスタンス上で一般的な操作を実行するためのシンプルな方法を提供します。さらに、Jenkins X では Kubernetes の名前空間の規約を拡張して、リリースパイプラインの推進階層を形成するための環境を作成することができます。

Jenkins X 環境は、特定のコードチームの開発、ステージング、本番環境などの仮想インフラ環境を表すことができます。環境間の推進ルールを定義することで、リリースをパイプラインを通じて自動的に、あるいは手動で移動させることができます。各環境は GitOps の方法論に従って管理されます。環境の望ましい状態は Git リポジトリに保持され、リポジトリへの変更をコミットしたり、ロールバックしたりすることで、Kubernetes 上の特定の環境の状態が変更されるトリガーとなります。

Kubernetes のクラスタは、`jx create cluster` コマンドを使って直接作成することができるので、障害が発生した場合でもクラスタを簡単に再現することができます。同様に、既存のクラスタ上で `jx upgrade platform` を使用して、Jenkins X プラットフォームをアップグレードすることもできる。Jenkins X は、`jx context` を使って複数の Kubernetes クラスタを操作したり、`jx environment` を使ってクラスタ内の複数の環境を切り替えたりすることをサポートしています。

開発者は、Kubernetes が提供する設定データやセキュリティ認証情報をクラスタ全体に分散させる機能に注意する必要があります。ConfigMaps は機密性のない設定メタデータのための名前と値のペアのセットを作成するために使用することができ、Secrets はセキュリティ認証情報とトークンのために同様のメカニズムを実行しますが、暗号化されています。Kubernetes はまた、ノード間のデプロイを最適化するために必要な Pod のリソースクォータを指定するメカニズムを提供しています。

デフォルトでは、Pod の状態は過渡的です。Pod のローカルファイルシステムに書き込まれたデータは、その Pod が削除されると失われます。開発者は、ノードの一般的な負荷分散プロセスの一部として、Kubernetes が一方的にいつでも Pod のインスタンスを削除して再作成することができるので、ローカルデータはいつでも失われる可能性があることに注意する必要があります。ステートフルデータが必要な場合は、Persistent Volumes を宣言し、特定の Pods のファイルシステム内にマウントする必要があります。

### Helm と Draft
---
Kubernetes と直接対話するには、`kubectl` コマンドラインユーティリティを使って手動で設定するか、API に様々な種類の YAML データを渡す必要があります。これは複雑で、人為的なミスが入り込む可能性があります。DevOps の原則である「コードとしての設定」に則り、Jenkins X では Helm と Draft を活用して、アプリケーションのためのアトミックな設定ブロックを作成しています。

Helm は、特定のアプリケーションやサービスを Kubernetes にデプロイするために必要なメタデータを指定するファイルのセットである Chart の概念を通じて、Kubernetes の設定を簡素化します。Kubernetes API に基づいた一連のボイラープレート YAML ファイルを維持するのではなく、Helm はテンプレート言語を使用して、単一の共有された値のセットから必要な YAML 仕様を作成します。これにより、デプロイ時に設定を選択的にオーバーライドできる再利用可能な Kubernetes アプリケーションを指定することが可能になります。

